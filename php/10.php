<?php
/*
数组-冒泡排序
Bubble Sort：一种计算机科学领域的较简单的排序算法
重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们【交换】过来
走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成
冒泡排序的算法思路：
1.比较相邻的元素
2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3.针对所有的元素重复以上的步骤，除了最后一个
4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

*/
$arr = array(1,4,2,9,7,5,8);

//2.想办法让下面可以每次找出最大值的代码重复执行
for($i=0,$len=count($arr);$i<$len;$i++){
    //1.想办法将最大的值放到最右边去
    for($j = 0,$len=count($arr);$j<$len-1-$i;$j++){
        //判断：两两相比
        if($arr[$j]>$arr[$j+1]){
            //左边比右边大：交换
            $temp = $arr[$j];//保存左边的值
            $arr[$j]=$arr[$j+1];//左边等于右边
            $arr[$j+1]=$temp;//右边等于左边
        }
    }
}
echo '<pre>';
print_r($arr);
echo '<hr>';
/*
数组选择排序
工作原理：每次从待排序的数据元素中选出最小或者最大的一个元素，存放在【起始】的位置，直到全部待排序的数据元素排完。
选择排序是不稳定的排序方法
*/
$arr1 = array(1,5,2,9,6,3,4);
//1.确定要交换多少次，一次只能找到一个最小的，需要找数组长度对应的次数
for($i=0,$len=count($arr1);$i<$len;$i++){
    //2.假设当前第一个已经排好序
    $min = $i;
    //3.拿该最小的取比较剩余的其他
    for($j=$i+1;$j<$len;$j++){
        //4.比较当前元素与选定的最小的元素
        if($arr1[$j]<$arr1[$min]){
            //说明当指定的$min不合适
            $min = $j;
        }
    }
    //5.交换当前选定的值与实际最小的元素值
    if($min!=$i){
        $temp = $arr1[$i];
        $arr1[$i]=$arr1[$min];
        $arr1[$min] = $temp;
    }
}
echo '<pre>';
print_r($arr1);
echo '<hr>';
/*
插入排序
将一个数据插入到已经排好序的有序数据中，从而得到一个新的有序数组，算法适用于少量数据的数组，是稳定排序方法。
1.认定第一个元素已经排好序
2.取出第二个元素，作为待插入数据
3.与已经排好序的数组的最右侧元素开始进行比较
4.如果后面的小于前面的：说明前面已经排好序的那个数组元素不在对的位置（向后移一个），然后让新的元素填充进入（继续向前比：高级）
5.重复前面的步骤：直到当前元素插入到对的位置
5.重复以上步骤，直到所有数组元素都插入到对的位置
*/
$arr2 = array(4,2,5,46,8,7,9);
//1.确定插入多少回（假设一个数组一次性插入到对的位置，同时第一个位置假设是对的）
for($i=1,$len=count($arr2);$i<$len;$i++){
    //2.取出当前要插入的元素的值
    $temp = $arr2[$i];
    //标记：默认说明当前要插入的数组的位置对的
    $change= false;
    //3.让该数据与前面已经排好序的数组元素重复比较（挨个比较），直到对的位置（交换）
    for($j=$i-1;$j>=0;$j--){
        //4.比较
        if($arr2[$j]>$temp){
            //说明当前要插入的元素，比前面的已经排好序的元素的值小：交换位置
            $arr2[$j+1]=$arr2[$j];
           // $arr2[$j]=$temp;
            //说明前面顺序的数组元素有不合适的位置
            $change= true;
        }else{
            //说明当前待插入元素，比前面的元素要大：说明位置正确
            break;
        }
    }
    //判断位置需要变动
    if($change){
       //有数据移动 ：站错位置了
       $arr2[$j+1]=$temp;
    }

}

echo '<pre>';
print_r($arr2);
echo '<hr>';
/*
快速排序
对冒泡排序的一种改进
通过一趟排序，将要排序的数据分割成独立两部分，其中一部分所有数据都比另外一部分所有数据要小，
然后再按此方法对这两部分数据分别进行快速排序，整个排序过程都可以递归进行，以此达到整个数据变成有序序列（递归）



*/







?>